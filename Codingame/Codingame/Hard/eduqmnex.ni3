using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;


namespace Codingame.Hard
{
    /**
     * Auto-generated code below aims at helping you parse
     * the standard input according to the problem statement.
     **/
    public class BenderSolution
    {
        public static void Main(string[] args)
        {
            var sr = new StringReader(args[0]);
            Console.SetIn(sr);
            string[] inputs = Console.ReadLine().Split(' ');
            int L = int.Parse(inputs[0]);
            int C = int.Parse(inputs[1]);



            Map map = new Map(L, C);
            for (int i = 0; i < L; i++)
            {
                sr = new StringReader(args[i+1]);
                Console.SetIn(sr);
                string row = Console.ReadLine();
                map.AddRow(i, row);
            }

            map.MemberScreenDump();

            Bender bender = new Bender();
            bender.InitGame();
            //string action;
            //do
            //{ 
            //    action = bender.MoveBender();
            //    //Write an action using Console.WriteLine()
            //    //To debug: Console.Error.WriteLine("Debug messages...");
            //   // Console.Error.WriteLine("x,y,d: " + bender.currentX + " , " + bender.currentY + " , " + bender.currentD);
            //    Console.WriteLine(action);
            //} while (!bender.FinishLine && action != "LOOP");
        }







    }

    public class Map
    {
        private char[,] map;


        public Map(int L, int C)
        {
            map = new char[L, C];
            map.Initialize();

            t1X = t1Y = t2X = t2Y = 0;
        }

        public int startX { get; set; }
        public int startY { get; set; }
        public int endX { get; set; }
        public int endY { get; set; }

        public int t1X { get; set; }
        public int t1Y { get; set; }
        public int t2X { get; set; }
        public int t2Y { get; set; }

        public void MemberScreenDump()
        {

            Console.WriteLine("startX: " + startX);
            Console.WriteLine("startY: " + startY);
            Console.WriteLine("endX: " + endX);
            Console.WriteLine("endY: " + endY);
            Console.WriteLine("t1X: " + t1X);
            Console.WriteLine("t1Y: " + t1Y);
            Console.WriteLine("t2X: " + t2X);
            Console.WriteLine("t2Y: " + t2Y);
            //Console.WriteLine("" + );
        }

        public void AddRow(int i, string row)
        {
            //Console.Error.WriteLine(row);
            var chrar = row.ToCharArray();

            // Console.Error.WriteLine(chrar[0]);
            //*map[i,] = new char[chrar.Length];
            for (int j = 0; j < chrar.Length; j++)
            {
                map[i, j] = chrar[j];
                if (chrar[j] == '@')
                {
                    startY = i;
                    startX = j;

                }
                else if (chrar[j] == '$')
                {
                    endY = i;
                    endX = j;
                }
                else if (chrar[j] == 'T')
                {
                    if (t1X == 0 && t1Y == 0)
                    {
                        t1Y = i;
                        t1X = j;
                    }
                    else
                    {
                        t2Y = i;
                        t2X = j;
                    }

                }
            }
        }

        public void KillObsticleX(int x, int y)
        {
            map[y, x] = ' ';
        }

        public char GetNode(int x, int y)
        {
            // Console.Error.WriteLine("X, Y " + x + ", " + y);


            return map[y, x];
        }


        public char GetProjectedNode(int x, int y)
        {
            // Console.Error.WriteLine("X, Y " + x + ", " + y);
            if (map[y, x] == 'T')
            {
                if (x == t1X && y == t1Y)
                {
                    x = t2X;
                    y = t2Y;
                }
                else
                {
                    x = t1X;
                    y = t1Y;
                }
            }

            return map[y, x];
        }

    }

    public class MoveManager
    {
        //public bool FinishLine;
        
        
        
        private string[] direction = new string[4] { "SOUTH", "EAST", "NORTH", "WEST" };

        private int GlobalDirectionChangeCounter = 0;
        private Dictionary<int, int> bounceReverse;
        private bool bounceIsReversed;
        private bool breakerIsOn;

        private bool killObsticle = false;

        public int currentX { get; set; }
        public int currentY { get; set; }
        public int currentD { get; set; }

        public int proposedX { get; set; }
        public int proposedY { get; set; }
        //public char proposedNode { get; set; }


      

        public char NodePeek(ref Map map)
        {
            proposedY = currentY;
            proposedX = currentX;
            switch (currentD)
            {
                case 2:
                    proposedY = currentY - 1;
                    //if (proposedY < 0)
                    //    proposedY = 0;
                    break;
                case 0:
                    proposedY = currentY + 1;
                    break;
                case 1:
                    proposedX = currentX + 1;
                    break;
                case 3:
                    proposedX = currentX - 1;
                    //if (proposedX < 0)
                    //    proposedX = 0;
                    break;
            }
            var proposedNode = map.GetProjectedNode(proposedX, proposedY);


            if(proposedNode == '#' || proposedNode == 'X')
            {
                //BlockedDirectionChange(proposedNode);
                if(BlockedDirectionChange(proposedNode))
                {
                    map.KillObsticleX(proposedX,proposedY);
                }
                else{
                    proposedNode = NodePeek(ref map);
                }
            }
            GlobalDirectionChangeCounter = 0;
            return proposedNode;
            
        }

        public bool BlockedDirectionChange(char pnode)
        {
            if((!breakerIsOn && pnode == 'X') || pnode == '#' )
            {
                currentD = GlobalDirectionChangeCounter;
                GlobalDirectionChangeCounter++;
                if(GlobalDirectionChangeCounter == 4)
                {
                    GlobalDirectionChangeCounter = 0;
                }
            }
            else
            {
                return true;
            }
            return false;
        }

        public string MoveBender(ref Map map)
        {
            int obsCCWTurn;
            int holder = currentD;
            var pnode = NodePeek(ref map);

            
           


            
            switch (pnode)
            {
                case '#':
                    //obsCCWTurn = 0;
                    
                    //do
                    //{
                    //    //Console.Error.WriteLine(obsCCWTurn);
                    //    currentD = bounceReverse[obsCCWTurn];
                    //    obsCCWTurn = (obsCCWTurn < 5) ? obsCCWTurn+1 : 1;
                    //    NodePeek();
                    //} while (proposedNode == '#'); 
                    
                    CounterCWMove();
                    break;
                case 'X':
                    if (!breakerIsOn)
                    {
                        obsCCWTurn = 1;
                        do
                        {
                            currentD = bounceReverse[obsCCWTurn];
                            obsCCWTurn = (obsCCWTurn < 5) ? obsCCWTurn + 1 : 1;
                            NodePeek();
                        } while (proposedNode == 'X');
                    }
                    else
                    {
                        map.KillObsticleX(proposedX, proposedY);
                    }
                    break;
                case '@':
                    return "LOOP";
                    break;
                case '$':
                    FinishLine = true;
                    break;
                case 'S':
                    currentD = 0;
                    break;
                case 'E':
                    currentD = 1;
                    break;
                case 'N':
                    currentD = 2;
                    break;
                case 'W':
                    currentD = 3;
                    break;
                case 'B':
                    SetBreakerMode(breakerIsOn);
                    break;
                case 'I':
                    SetToggleBounce(bounceIsReversed);
                    break;
                case 'T':

                    break;



            }
           
            currentX = proposedX;
            currentY = proposedY;
            //mover.CurrentDirection = currentD;

            //if (map.GetNode(currentX, currentY) == '$')
            //    return "FINISHED";  

            return direction[currentD];

        }
    }


    public class Bender
    {
        public bool FinishLine;
        private int proposedX;
        private int proposedY;
        private char proposedNode;
        private Map map;
        
        private string[] direction;
        private Dictionary<int, int> bounceReverse;
        private bool bounceIsReversed;
        private bool breakerIsOn;
        public Bender(int L, int C)
        {
            map = new Map(L, C);
            currentD = 0;
            
            direction = new string[4] { "SOUTH", "EAST", "NORTH", "WEST" };
            FinishLine = false;
            SetToggleBounce(true);
            SetBreakerMode(true);


        }

        public int currentX { get; set; }
        public int currentY { get; set; }
        public int currentD { get; set; }

        public void AddMapRow(int i, string row)
        {
            map.AddRow(i, row);
        }

        private void initProposedXY()
        {
            proposedY = currentY;
            proposedX = currentX;
        }

        public void InitGame()
        {
            currentX = map.startX;
            currentY = map.startY;
        }

        public void NodePeek()
        {
            initProposedXY();
            switch (currentD)
            {
                case 2:
                    proposedY = currentY - 1;
                    if (proposedY < 0)
                        proposedY = 0;
                    break;
                case 0:
                    proposedY = currentY + 1;
                    break;
                case 1:
                    proposedX = currentX + 1;
                    break;
                case 3:
                    proposedX = currentX - 1;
                    if (proposedX < 0)
                        proposedX = 0;
                    break;
            }
            proposedNode = map.GetProjectedNode(proposedX, proposedY);
            
        }

        public string MoveBender()
        {
            int obsCCWTurn;
            int holder = currentD;
            NodePeek();

            
            switch (proposedNode)
            {
                case '#':
                    obsCCWTurn = 1;
                    
                    do
                    {
                        //Console.Error.WriteLine(obsCCWTurn);
                        currentD = bounceReverse[obsCCWTurn];
                        obsCCWTurn = (obsCCWTurn < 5) ? obsCCWTurn+1 : 1;
                        NodePeek();
                    } while (proposedNode == '#'); 
                    
                    //CounterCWMove();
                    break;
                case 'X':
                    if (!breakerIsOn)
                    {
                        obsCCWTurn = 1;
                        do
                        {
                            currentD = bounceReverse[obsCCWTurn];
                            obsCCWTurn = (obsCCWTurn < 5) ? obsCCWTurn + 1 : 1;
                            NodePeek();
                        } while (proposedNode == 'X');
                    }
                    else
                    {
                        map.KillObsticleX(proposedX, proposedY);
                    }
                    break;
                case '@':
                    return "LOOP";
                    break;
                case '$':
                    FinishLine = true;
                    break;
                case 'S':
                    currentD = 0;
                    break;
                case 'E':
                    currentD = 1;
                    break;
                case 'N':
                    currentD = 2;
                    break;
                case 'W':
                    currentD = 3;
                    break;
                case 'B':
                    SetBreakerMode(breakerIsOn);
                    break;
                case 'I':
                    SetToggleBounce(bounceIsReversed);
                    break;
                case 'T':

                    break;



            }
           
            currentX = proposedX;
            currentY = proposedY;
            //mover.CurrentDirection = currentD;

            //if (map.GetNode(currentX, currentY) == '$')
            //    return "FINISHED";  

            return direction[currentD];

        }


    
    



        //public void CounterCWMove()
        //{

        //    obsCCWTurn += 1;
        //    currentD = bounceReverse[obsCCWTurn];
            
        //   // Console.Error.WriteLine("obsCCWTurn " + obsCCWTurn + " " + currentD);
        //    //Move2();
        //    //MoveBender();
        //   // if(proposedNode != 'X' && proposedNode != '#')
        //    if (obsCCWTurn >= 4)
        //        obsCCWTurn = 0;
        //}

        private void SetToggleBounce(bool isInit)
        {

            bounceReverse = new Dictionary<int, int>();

            if (isInit)
            {
                bounceIsReversed = false;
                bounceReverse.Add(1, 0);
                bounceReverse.Add(2, 1);
                bounceReverse.Add(3, 2);
                bounceReverse.Add(4, 3);
            }
            else
            {
                bounceIsReversed = true;
                bounceReverse.Add(1, 3);
                bounceReverse.Add(2, 2);
                bounceReverse.Add(3, 1);
                bounceReverse.Add(4, 0);
            }
        }

        private void SetBreakerMode(bool isInit)
        {
            breakerIsOn = !isInit;
        }

    }

    
}